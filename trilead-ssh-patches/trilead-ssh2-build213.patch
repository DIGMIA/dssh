diff -urN -x '*.svn' src.orig/com/trilead/ssh2/Connection.java src/com/trilead/ssh2/Connection.java
--- src.orig/com/trilead/ssh2/Connection.java	2008-04-01 14:48:37.000000000 +0200
+++ src/com/trilead/ssh2/Connection.java	2008-07-29 15:37:16.000000000 +0200
@@ -1,6 +1,7 @@
 
 package com.trilead.ssh2;
 
+import com.trilead.ssh2.transport.GenericTransportManager;
 import java.io.CharArrayWriter;
 import java.io.File;
 import java.io.FileReader;
@@ -88,6 +89,7 @@
 
 	private AuthenticationManager am;
 
+
 	private boolean authenticated = false;
 	private ChannelManager cm;
 
@@ -99,7 +101,7 @@
 
 	private final int port;
 
-	private TransportManager tm;
+	private GenericTransportManager tm;
 
 	private boolean tcpNoDelay = false;
 
@@ -192,7 +194,52 @@
 
 		return authenticated;
 	}
+	
+	/**
+	 * After a successful connect, one has to authenticate oneself. This method
+	 * allows you to test particular public key (f.e. if you need to prompt user
+	 * for passphrase, it is a good idea to try the key first). 
+	 * <p>
+	 * If the public key is accepted, <code>true</code> will be
+	 * returned. If the server does not accept the request, <code>false</code>
+	 * is returned and one can retry either by using this or any other
+	 * authentication method (use the <code>getRemainingAuthMethods</code>
+	 * method to get a list of the remaining possible methods).
+	 * 
+	 * @param user
+	 *            A <code>String</code> holding the username.
+	 * @param publicKey
+	 *            A <code>Object</code> containing the RSA or DSA public key
+	 *            (instances of DSAPublicKey or RSAPublicKey). You can
+	 *            get them in this format by using PublicKeyDecoder.
+	 *
+	 * @return whether the public key is accepted by the server.
+	 * @throws IOException
+	 * 
+	 */
+	public synchronized boolean tryPublicKey(String user, Object publicKey) throws IOException
+	{
+		if (tm == null)
+			throw new IllegalStateException("Connection is not established!");
+
+		if (authenticated)
+			throw new IllegalStateException("Connection is already authenticated!");
+
+		if (am == null)
+			am = new AuthenticationManager(tm);
+
+		if (cm == null)
+			cm = new ChannelManager(tm);
+
+		if (user == null)
+			throw new IllegalArgumentException("user argument is null");
 
+		if (publicKey == null)
+			throw new IllegalArgumentException("publicKey argument is null");
+
+		return am.tryPublicKey(user, publicKey);
+	}
+	
 	/**
 	 * A wrapper that calls
 	 * {@link #authenticateWithKeyboardInteractive(String, String[], InteractiveCallback)
@@ -577,6 +624,10 @@
 		return connect(verifier, 0, 0);
 	}
 
+        protected GenericTransportManager createTransportManager() throws IOException{
+            return new TransportManager(hostname, port);
+        }
+        
 	/**
 	 * Connect to the SSH-2 server and, as soon as the server has presented its
 	 * host key, use the
@@ -679,7 +730,7 @@
 
 		final TimeoutState state = new TimeoutState();
 
-		tm = new TransportManager(hostname, port);
+		tm = createTransportManager();
 
 		tm.setConnectionMonitors(connectionMonitors);
 
@@ -1495,4 +1546,17 @@
 
 		cm.requestGlobalTrileadPing();
 	}
+	
+        public void setAuthenticationManager(AuthenticationManager am) {
+            this.am = am;
+        }
+    
+        public GenericTransportManager getTransportManager() {
+    	    return tm;
+	}
+	
+	// TODO: This is a pretty ugly hack right now :(
+	public void setAuthenticated(boolean authenticated) {
+		this.authenticated = authenticated;
+	}
 }
diff -urN -x '*.svn' src.orig/com/trilead/ssh2/Session.java src/com/trilead/ssh2/Session.java
--- src.orig/com/trilead/ssh2/Session.java	2008-04-01 14:48:37.000000000 +0200
+++ src/com/trilead/ssh2/Session.java	2008-07-29 15:37:16.000000000 +0200
@@ -130,6 +130,44 @@
 				terminal_modes);
 	}
 
+        
+	/**
+	 * Request window change.
+	 * <p>
+	 * This method may only be called after a program or shell is started
+         * in this session.
+	 * <p>
+	 * Zero dimension parameters are ignored. The character/row dimensions
+	 * override the pixel dimensions (when nonzero). Pixel dimensions refer to
+	 * the drawable area of the window. The dimension parameters are only
+	 * informational. 
+         *
+	 * @param term_width_characters
+	 *            terminal width, characters (e.g., 80)
+	 * @param term_height_characters
+	 *            terminal height, rows (e.g., 24)
+	 * @param term_width_pixels
+	 *            terminal width, pixels (e.g., 640)
+	 * @param term_height_pixels
+	 *            terminal height, pixels (e.g., 480)
+	 * @throws IOException
+	 */
+	public void requestWindowSizeChange(int term_width_characters, int term_height_characters, int term_width_pixels,
+			int term_height_pixels) throws IOException
+	{
+		synchronized (this)
+		{
+			/* The following is just a nicer error, we would catch it anyway later in the channel code */
+			if (flag_closed)
+				throw new IOException("This session is closed.");
+
+			if ((!flag_pty_requested) && (!flag_execution_started))
+				throw new IOException("Cannot change window size at this stage, PTY or command execution was not yet requested.");
+		}
+
+		cm.requestWindowSizeChange(cn, term_width_characters, term_height_characters, term_width_pixels, term_height_pixels);
+	}
+        
 	/**
 	 * Request X11 forwarding for the current session.
 	 * <p>
diff -urN -x '*.svn' src.orig/com/trilead/ssh2/StreamConnection.java src/com/trilead/ssh2/StreamConnection.java
--- src.orig/com/trilead/ssh2/StreamConnection.java	1970-01-01 01:00:00.000000000 +0100
+++ src/com/trilead/ssh2/StreamConnection.java	2008-07-29 15:37:16.000000000 +0200
@@ -0,0 +1,44 @@
+/*
+ * StreamConnection.java
+ *
+ * Created on April 14, 2007, 8:55 PM
+ *
+ * To change this template, choose Tools | Template Manager
+ * and open the template in the editor.
+ */
+
+package com.trilead.ssh2;
+
+import com.trilead.ssh2.transport.GenericTransportManager;
+import com.trilead.ssh2.transport.StreamTransportManager;
+import java.io.IOException;
+
+/**
+ *
+ * @author juraj
+ */
+public class StreamConnection extends Connection {
+    
+    private LocalStreamForwarder stream = null;
+    
+    public StreamConnection(String hostname, int port) {
+        super(hostname, port);
+    }
+    
+    
+    public StreamConnection(String hostname, int port, LocalStreamForwarder stream) {
+        super(hostname, port);
+        this.stream = stream;
+    }
+    
+    public StreamConnection(String hostname, int port, Connection connection) throws IOException {
+        super(hostname, port);
+        this.stream = connection.createLocalStreamForwarder(hostname, port);
+    }
+    
+    
+    protected GenericTransportManager createTransportManager() throws IOException{
+        return new StreamTransportManager(getHostname(), getPort(), stream);
+    }
+    
+}
diff -urN -x '*.svn' src.orig/com/trilead/ssh2/auth/AuthenticationManager.java src/com/trilead/ssh2/auth/AuthenticationManager.java
--- src.orig/com/trilead/ssh2/auth/AuthenticationManager.java	2008-04-01 14:48:37.000000000 +0200
+++ src/com/trilead/ssh2/auth/AuthenticationManager.java	2008-07-29 15:37:16.000000000 +0200
@@ -1,6 +1,8 @@
 
 package com.trilead.ssh2.auth;
 
+import com.trilead.ssh2.signature.DSAPublicKey;
+import com.trilead.ssh2.signature.RSAPublicKey;
 import java.io.IOException;
 import java.security.SecureRandom;
 import java.util.Vector;
@@ -26,7 +28,7 @@
 import com.trilead.ssh2.signature.RSASHA1Verify;
 import com.trilead.ssh2.signature.RSASignature;
 import com.trilead.ssh2.transport.MessageHandler;
-import com.trilead.ssh2.transport.TransportManager;
+import com.trilead.ssh2.transport.GenericTransportManager;
 
 
 /**
@@ -37,25 +39,25 @@
  */
 public class AuthenticationManager implements MessageHandler
 {
-	TransportManager tm;
+	protected GenericTransportManager tm;
 
 	Vector packets = new Vector();
 	boolean connectionClosed = false;
 
 	String banner;
 
-	String[] remainingMethods = new String[0];
-	boolean isPartialSuccess = false;
+	protected String[] remainingMethods = new String[0];
+	protected boolean isPartialSuccess = false;
 
-	boolean authenticated = false;
-	boolean initDone = false;
+	protected boolean authenticated = false;
+	protected boolean initDone = false;
 
-	public AuthenticationManager(TransportManager tm)
+	public AuthenticationManager(GenericTransportManager tm)
 	{
 		this.tm = tm;
 	}
 
-	boolean methodPossible(String methName)
+	protected boolean methodPossible(String methName)
 	{
 		if (remainingMethods == null)
 			return false;
@@ -93,7 +95,7 @@
 		}
 	}
 
-	byte[] getNextMessage() throws IOException
+	protected byte[] getNextMessage() throws IOException
 	{
 		while (true)
 		{
@@ -119,7 +121,7 @@
 		return isPartialSuccess;
 	}
 
-	private boolean initialize(String user) throws IOException
+	protected boolean initialize(String user) throws IOException
 	{
 		if (initDone == false)
 		{
@@ -262,7 +264,68 @@
 			throw (IOException) new IOException("Publickey authentication failed.").initCause(e);
 		}
 	}
+	
+	public boolean tryPublicKey(String user, Object publicKey)
+			throws IOException
+	{
+		try
+		{
+			if (methodPossible("publickey") == false)
+				throw new IOException("Authentication method publickey not supported by the server at this stage.");
+
+			// TODO: register callback
+			
+			if (publicKey instanceof DSAPublicKey)
+			{
+				DSAPublicKey pk = (DSAPublicKey) publicKey;
+
+				byte[] pk_enc = DSASHA1Verify.encodeSSHDSAPublicKey(pk);
+
+				TypesWriter tw = new TypesWriter();
+
+				byte[] H = tm.getSessionIdentifier();
+
+				PacketUserauthRequestPublicKey ua = new PacketUserauthRequestPublicKey("ssh-connection", user,
+						"ssh-dss", pk_enc);
+				tm.sendMessage(ua.getPayload());
+			}
+			else if (publicKey instanceof RSAPublicKey)
+			{
+				RSAPublicKey pk = (RSAPublicKey) publicKey;
+
+				byte[] pk_enc = RSASHA1Verify.encodeSSHRSAPublicKey(pk);
+
+				PacketUserauthRequestPublicKey ua = new PacketUserauthRequestPublicKey("ssh-connection", user,
+						"ssh-rsa", pk_enc);
+				tm.sendMessage(ua.getPayload());
+			}
+			else
+			{
+				throw new IOException("Unknown public key type");
+			}
+
+			byte[] ar = getNextMessage();
+
+			if (ar[0] == Packets.SSH_MSG_USERAUTH_PK_OK)
+			{
+				return true;
+			}
 
+			if (ar[0] == Packets.SSH_MSG_USERAUTH_FAILURE)
+			{
+				return false;
+			}
+
+			throw new IOException("Unexpected SSH message (type " + ar[0] + ")");
+
+		}
+		catch (IOException e)
+		{
+			tm.close(e, false);
+			throw (IOException) new IOException("Publickey authentication failed.").initCause(e);
+		}
+	}
+	
 	public boolean authenticateNone(String user) throws IOException
 	{
 		try
diff -urN -x '*.svn' src.orig/com/trilead/ssh2/channel/ChannelManager.java src/com/trilead/ssh2/channel/ChannelManager.java
--- src.orig/com/trilead/ssh2/channel/ChannelManager.java	2008-04-01 14:48:37.000000000 +0200
+++ src/com/trilead/ssh2/channel/ChannelManager.java	2008-07-29 15:37:16.000000000 +0200
@@ -17,13 +17,14 @@
 import com.trilead.ssh2.packets.PacketOpenSessionChannel;
 import com.trilead.ssh2.packets.PacketSessionExecCommand;
 import com.trilead.ssh2.packets.PacketSessionPtyRequest;
+import com.trilead.ssh2.packets.PacketSessionWindowChangeRequest;
 import com.trilead.ssh2.packets.PacketSessionStartShell;
 import com.trilead.ssh2.packets.PacketSessionSubsystemRequest;
 import com.trilead.ssh2.packets.PacketSessionX11Request;
 import com.trilead.ssh2.packets.Packets;
 import com.trilead.ssh2.packets.TypesReader;
 import com.trilead.ssh2.transport.MessageHandler;
-import com.trilead.ssh2.transport.TransportManager;
+import com.trilead.ssh2.transport.GenericTransportManager;
 
 /**
  * ChannelManager. Please read the comments in Channel.java.
@@ -39,7 +40,7 @@
 
 	private HashMap x11_magic_cookies = new HashMap();
 
-	private TransportManager tm;
+	private GenericTransportManager tm;
 
 	private Vector channels = new Vector();
 	private int nextLocalChannel = 100;
@@ -53,7 +54,7 @@
 
 	private boolean listenerThreadsAllowed = true;
 
-	public ChannelManager(TransportManager tm)
+	public ChannelManager(GenericTransportManager tm)
 	{
 		this.tm = tm;
 		tm.registerMessageHandler(this, 80, 100);
@@ -857,6 +858,40 @@
 		}
 	}
 
+	public void requestWindowSizeChange(Channel c, int term_width_characters, int term_height_characters,
+			int term_width_pixels, int term_height_pixels) throws IOException
+	{
+		PacketSessionWindowChangeRequest spr;
+
+		synchronized (c)
+		{
+			if (c.state != Channel.STATE_OPEN)
+				throw new IOException("Cannot change window size on this channel (" + c.getReasonClosed() + ")");
+
+			spr = new PacketSessionWindowChangeRequest(c.remoteID, true, term_width_characters, term_height_characters,
+					term_width_pixels, term_height_pixels);
+
+			c.successCounter = c.failedCounter = 0;
+		}
+
+		synchronized (c.channelSendLock)
+		{
+			if (c.closeMessageSent)
+				throw new IOException("Cannot change window size on this channel (" + c.getReasonClosed() + ")");
+			tm.sendMessage(spr.getPayload());
+		}
+
+		try
+		{
+			if (waitForChannelRequestResult(c) == false)
+				throw new IOException("The server denied the request.");
+                }
+		catch (IOException e)
+		{
+			throw (IOException) new IOException("Change window size request failed").initCause(e);
+		}
+	}
+
 	/**
 	 * Wait until for a condition.
 	 * 
diff -urN -x '*.svn' src.orig/com/trilead/ssh2/crypto/PEMDecoder.java src/com/trilead/ssh2/crypto/PEMDecoder.java
--- src.orig/com/trilead/ssh2/crypto/PEMDecoder.java	2008-04-01 14:48:37.000000000 +0200
+++ src/com/trilead/ssh2/crypto/PEMDecoder.java	2008-07-29 15:37:16.000000000 +0200
@@ -120,7 +120,7 @@
 		return tmp;
 	}
 
-	private static final PEMStructure parsePEM(char[] pem) throws IOException
+	public static final PEMStructure parsePEM(char[] pem) throws IOException
 	{
 		PEMStructure ps = new PEMStructure();
 
@@ -308,10 +308,8 @@
 		return false;
 	}
 
-	public static Object decode(char[] pem, String password) throws IOException
+	public static Object decode(PEMStructure ps, String password) throws IOException
 	{
-		PEMStructure ps = parsePEM(pem);
-
 		if (isPEMEncrypted(ps))
 		{
 			if (password == null)
@@ -373,5 +371,10 @@
 
 		throw new IOException("PEM problem: it is of unknown type");
 	}
+		
+	public static Object decode(char[] pem, String password) throws IOException
+	{
+		return decode(parsePEM(pem), password);
+	}
 
 }
diff -urN -x '*.svn' src.orig/com/trilead/ssh2/crypto/PublicKeyDecoder.java src/com/trilead/ssh2/crypto/PublicKeyDecoder.java
--- src.orig/com/trilead/ssh2/crypto/PublicKeyDecoder.java	1970-01-01 01:00:00.000000000 +0100
+++ src/com/trilead/ssh2/crypto/PublicKeyDecoder.java	2008-07-29 15:37:16.000000000 +0200
@@ -0,0 +1,78 @@
+/*
+ * PublicKeyDecoder.java
+ *
+ * Created on May 3, 2007, 2:28 PM
+ *
+ */
+
+package com.trilead.ssh2.crypto;
+
+import com.trilead.ssh2.signature.DSASHA1Verify;
+import com.trilead.ssh2.signature.RSASHA1Verify;
+import java.io.BufferedReader;
+import java.io.CharArrayReader;
+import java.io.CharArrayWriter;
+import java.io.File;
+import java.io.FileReader;
+import java.io.IOException;
+
+/**
+ *
+ * @author juraj
+ */
+public class PublicKeyDecoder {
+	
+	public PublicKeyDecoder() {
+	}
+	
+	public static Object parseKey(char[] publicKeyData) throws IOException {
+		BufferedReader br = new BufferedReader(new CharArrayReader(publicKeyData));
+		
+		Object key = null;
+		String line = br.readLine();
+		
+		if (line == null)
+			return null;
+		
+		line = line.trim();
+		
+		String[] arr = line.split(" ");
+		
+		if (arr.length >= 2) {
+			if ((arr[0].compareTo("ssh-rsa") == 0) || (arr[0].compareTo("ssh-dss") == 0)) {
+				// String keyname = arr[2];
+				
+				byte[] msg = Base64.decode(arr[1].toCharArray());
+				
+				if ("ssh-rsa".equals(arr[0])) {
+					key = RSASHA1Verify.decodeSSHRSAPublicKey(msg);
+				} else if ("ssh-dss".equals(arr[0])) {
+					key = DSASHA1Verify.decodeSSHDSAPublicKey(msg);
+				}
+			}
+		}
+		return key;
+	}
+	
+	public static Object parseKey(File publicKey) throws IOException {
+		char[] buff = new char[512];
+		
+		CharArrayWriter cw = new CharArrayWriter();
+		
+		publicKey.createNewFile();
+		
+		FileReader fr = new FileReader(publicKey);
+		
+		while (true) {
+			int len = fr.read(buff);
+			if (len < 0)
+				break;
+			cw.write(buff, 0, len);
+		}
+		
+		fr.close();
+		
+		return parseKey(cw.toCharArray());
+	}
+	
+}
\ No newline at end of file
diff -urN -x '*.svn' src.orig/com/trilead/ssh2/packets/PacketSessionWindowChangeRequest.java src/com/trilead/ssh2/packets/PacketSessionWindowChangeRequest.java
--- src.orig/com/trilead/ssh2/packets/PacketSessionWindowChangeRequest.java	1970-01-01 01:00:00.000000000 +0100
+++ src/com/trilead/ssh2/packets/PacketSessionWindowChangeRequest.java	2008-07-29 15:37:16.000000000 +0200
@@ -0,0 +1,52 @@
+package com.trilead.ssh2.packets;
+
+
+/**
+ * PacketSessionWindowChangeRequest.
+ * 
+ * @author Juraj Bednar, juraj.bednar@digmia.com
+ * @version $Id: PacketSessionWindowChangeRequest.java,v 1.0 $
+ */
+public class PacketSessionWindowChangeRequest
+{
+	byte[] payload;
+
+	public int recipientChannelID;
+	public boolean wantReply;
+	public String term;
+	public int character_width;
+	public int character_height;
+	public int pixel_width;
+	public int pixel_height;
+	public byte[] terminal_modes;
+
+	public PacketSessionWindowChangeRequest(int recipientChannelID, boolean wantReply,
+			int character_width, int character_height, int pixel_width, int pixel_height)
+	{
+		this.recipientChannelID = recipientChannelID;
+		this.wantReply = wantReply;
+		this.character_width = character_width;
+		this.character_height = character_height;
+		this.pixel_width = pixel_width;
+		this.pixel_height = pixel_height;
+	}
+
+	public byte[] getPayload()
+	{
+		if (payload == null)
+		{
+			TypesWriter tw = new TypesWriter();
+			tw.writeByte(Packets.SSH_MSG_CHANNEL_REQUEST);
+			tw.writeUINT32(recipientChannelID);
+			tw.writeString("window-change");
+			tw.writeBoolean(wantReply);
+			tw.writeUINT32(character_width);
+			tw.writeUINT32(character_height);
+			tw.writeUINT32(pixel_width);
+			tw.writeUINT32(pixel_height);
+
+			payload = tw.getBytes();
+		}
+		return payload;
+	}
+}
diff -urN -x '*.svn' src.orig/com/trilead/ssh2/packets/PacketUserauthRequestPublicKey.java src/com/trilead/ssh2/packets/PacketUserauthRequestPublicKey.java
--- src.orig/com/trilead/ssh2/packets/PacketUserauthRequestPublicKey.java	2008-04-01 14:48:37.000000000 +0200
+++ src/com/trilead/ssh2/packets/PacketUserauthRequestPublicKey.java	2008-07-29 15:37:16.000000000 +0200
@@ -18,6 +18,7 @@
 	String pkAlgoName;
 	byte[] pk;
 	byte[] sig;
+	boolean haveSig;
 
 	public PacketUserauthRequestPublicKey(String serviceName, String user,
 			String pkAlgorithmName, byte[] pk, byte[] sig)
@@ -26,9 +27,20 @@
 		this.userName = user;
 		this.pkAlgoName = pkAlgorithmName;
 		this.pk = pk;
+		this.haveSig = true;
 		this.sig = sig;
 	}
-
+	
+	public PacketUserauthRequestPublicKey(String serviceName, String user,
+			String pkAlgorithmName, byte[] pk)
+	{
+		this.serviceName = serviceName;
+		this.userName = user;
+		this.pkAlgoName = pkAlgorithmName;
+		this.pk = pk;
+		this.haveSig = false;
+	}
+	
 	public PacketUserauthRequestPublicKey(byte payload[], int off, int len) throws IOException
 	{
 		this.payload = new byte[len];
@@ -54,10 +66,11 @@
 			tw.writeString(userName);
 			tw.writeString(serviceName);
 			tw.writeString("publickey");
-			tw.writeBoolean(true);
+			tw.writeBoolean(haveSig);
 			tw.writeString(pkAlgoName);
 			tw.writeString(pk, 0, pk.length);
-			tw.writeString(sig, 0, sig.length);
+			if (haveSig)
+				tw.writeString(sig, 0, sig.length);
 			payload = tw.getBytes();
 		}
 		return payload;
diff -urN -x '*.svn' src.orig/com/trilead/ssh2/packets/Packets.java src/com/trilead/ssh2/packets/Packets.java
--- src.orig/com/trilead/ssh2/packets/Packets.java	2008-04-01 14:48:37.000000000 +0200
+++ src/com/trilead/ssh2/packets/Packets.java	2008-07-29 15:37:16.000000000 +0200
@@ -33,6 +33,7 @@
 	public static final int SSH_MSG_USERAUTH_SUCCESS = 52;
 	public static final int SSH_MSG_USERAUTH_BANNER = 53;
 	public static final int SSH_MSG_USERAUTH_INFO_REQUEST = 60;
+	public static final int SSH_MSG_USERAUTH_PK_OK = 60;
 	public static final int SSH_MSG_USERAUTH_INFO_RESPONSE = 61;
 
 	public static final int SSH_MSG_GLOBAL_REQUEST = 80;
diff -urN -x '*.svn' src.orig/com/trilead/ssh2/signature/DSAPrivateKey.java src/com/trilead/ssh2/signature/DSAPrivateKey.java
--- src.orig/com/trilead/ssh2/signature/DSAPrivateKey.java	2008-04-01 14:48:37.000000000 +0200
+++ src/com/trilead/ssh2/signature/DSAPrivateKey.java	2008-07-29 15:37:16.000000000 +0200
@@ -1,5 +1,6 @@
 package com.trilead.ssh2.signature;
 
+import java.io.Serializable;
 import java.math.BigInteger;
 
 /**
@@ -8,13 +9,16 @@
  * @author Christian Plattner, plattner@trilead.com
  * @version $Id: DSAPrivateKey.java,v 1.1 2007/10/15 12:49:57 cplattne Exp $
  */
-public class DSAPrivateKey
+public class DSAPrivateKey implements Serializable
 {
 	private BigInteger p;
 	private BigInteger q;
 	private BigInteger g;
 	private BigInteger x;
 	private BigInteger y;
+	
+	public DSAPrivateKey() {
+	}
 
 	public DSAPrivateKey(BigInteger p, BigInteger q, BigInteger g,
 			BigInteger y, BigInteger x)
diff -urN -x '*.svn' src.orig/com/trilead/ssh2/signature/DSAPublicKey.java src/com/trilead/ssh2/signature/DSAPublicKey.java
--- src.orig/com/trilead/ssh2/signature/DSAPublicKey.java	2008-04-01 14:48:37.000000000 +0200
+++ src/com/trilead/ssh2/signature/DSAPublicKey.java	2008-07-29 15:37:16.000000000 +0200
@@ -1,5 +1,6 @@
 package com.trilead.ssh2.signature;
 
+import java.io.Serializable;
 import java.math.BigInteger;
 
 /**
@@ -8,12 +9,15 @@
  * @author Christian Plattner, plattner@trilead.com
  * @version $Id: DSAPublicKey.java,v 1.1 2007/10/15 12:49:57 cplattne Exp $
  */
-public class DSAPublicKey
+public class DSAPublicKey implements Serializable
 {
 	private BigInteger p;
 	private BigInteger q;
 	private BigInteger g;
 	private BigInteger y;
+	
+	public DSAPublicKey() {
+	}
 
 	public DSAPublicKey(BigInteger p, BigInteger q, BigInteger g, BigInteger y)
 	{
diff -urN -x '*.svn' src.orig/com/trilead/ssh2/signature/RSAPrivateKey.java src/com/trilead/ssh2/signature/RSAPrivateKey.java
--- src.orig/com/trilead/ssh2/signature/RSAPrivateKey.java	2008-04-01 14:48:37.000000000 +0200
+++ src/com/trilead/ssh2/signature/RSAPrivateKey.java	2008-07-29 15:37:16.000000000 +0200
@@ -1,5 +1,6 @@
 package com.trilead.ssh2.signature;
 
+import java.io.Serializable;
 import java.math.BigInteger;
 
 /**
@@ -8,12 +9,15 @@
  * @author Christian Plattner, plattner@trilead.com
  * @version $Id: RSAPrivateKey.java,v 1.1 2007/10/15 12:49:57 cplattne Exp $
  */
-public class RSAPrivateKey
+public class RSAPrivateKey implements Serializable
 {
 	private BigInteger d;
 	private BigInteger e;
 	private BigInteger n;
 
+	public RSAPrivateKey() {
+	}
+	
 	public RSAPrivateKey(BigInteger d, BigInteger e, BigInteger n)
 	{
 		this.d = d;
diff -urN -x '*.svn' src.orig/com/trilead/ssh2/signature/RSAPublicKey.java src/com/trilead/ssh2/signature/RSAPublicKey.java
--- src.orig/com/trilead/ssh2/signature/RSAPublicKey.java	2008-04-01 14:48:37.000000000 +0200
+++ src/com/trilead/ssh2/signature/RSAPublicKey.java	2008-07-29 15:37:16.000000000 +0200
@@ -1,5 +1,6 @@
 package com.trilead.ssh2.signature;
 
+import java.io.Serializable;
 import java.math.BigInteger;
 
 /**
@@ -8,11 +9,14 @@
  * @author Christian Plattner, plattner@trilead.com
  * @version $Id: RSAPublicKey.java,v 1.1 2007/10/15 12:49:57 cplattne Exp $
  */
-public class RSAPublicKey
+public class RSAPublicKey implements Serializable
 {
 	BigInteger e;
 	BigInteger n;
 
+	public RSAPublicKey() {
+	}
+		
 	public RSAPublicKey(BigInteger e, BigInteger n)
 	{
 		this.e = e;
diff -urN -x '*.svn' src.orig/com/trilead/ssh2/transport/GenericTransportManager.java src/com/trilead/ssh2/transport/GenericTransportManager.java
--- src.orig/com/trilead/ssh2/transport/GenericTransportManager.java	1970-01-01 01:00:00.000000000 +0100
+++ src/com/trilead/ssh2/transport/GenericTransportManager.java	2008-07-29 15:37:16.000000000 +0200
@@ -0,0 +1,486 @@
+/*
+ * GenericTransportManager.java
+ *
+ * Created on April 14, 2007, 8:03 PM
+ */
+
+package com.trilead.ssh2.transport;
+
+import com.trilead.ssh2.ConnectionInfo;
+import com.trilead.ssh2.ConnectionMonitor;
+import com.trilead.ssh2.DHGexParameters;
+import com.trilead.ssh2.ProxyData;
+import com.trilead.ssh2.ServerHostKeyVerifier;
+import com.trilead.ssh2.crypto.CryptoWishList;
+import com.trilead.ssh2.crypto.cipher.BlockCipher;
+import com.trilead.ssh2.crypto.digest.MAC;
+import com.trilead.ssh2.log.Logger;
+import com.trilead.ssh2.packets.PacketDisconnect;
+import com.trilead.ssh2.packets.Packets;
+import com.trilead.ssh2.packets.TypesReader;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.security.SecureRandom;
+import java.util.Vector;
+
+/**
+ *
+ * @author Juraj Bednar, juraj.bednar@digmia.com
+ */
+public abstract class GenericTransportManager {
+    
+    protected static final Logger log = Logger.getLogger(GenericTransportManager.class);
+    
+    protected final Vector asynchronousQueue = new Vector();
+    protected Thread asynchronousThread = null;
+    String hostname;
+    int port;
+    
+    public GenericTransportManager(String hostname, int port) {
+        this.hostname = hostname;
+        this.port = port;
+    }
+    
+    boolean connectionClosed = false;
+    Vector connectionMonitors = new Vector();
+    Object connectionSemaphore = new Object();
+    boolean flagKexOngoing = false;
+    KexManager km;
+    Vector messageHandlers = new Vector();
+    boolean monitorsWereInformed = false;
+    Throwable reasonClosedCause = null;
+    Thread receiveThread;
+    TransportConnection tc;
+    
+    
+    class AsynchronousWorker extends Thread {
+        public void run() {
+            while (true) {
+                byte[] msg = null;
+                synchronized (asynchronousQueue) {
+                    if (asynchronousQueue.size()  == 0) {
+                        /* After the queue is empty for about 2 seconds, stop this thread */
+                        
+                        try {
+                            asynchronousQueue.wait(2000);
+                        } catch (InterruptedException e) {
+                            /* OKOK, if somebody interrupts us, then we may die earlier. */
+                        }
+                        
+                        if (asynchronousQueue.size()  == 0) {
+                            asynchronousThread = null;
+                            return;
+                        }
+                    }
+                    
+                    msg = (byte[]) asynchronousQueue.remove(0);
+                }
+                
+                /* The following invocation may throw an IOException.
+                 * There is no point in handling it - it simply means
+                 * that the connection has a problem and we should stop
+                 * sending asynchronously messages. We do not need to signal that
+                 * we have exited (asynchronousThread = null): further
+                 * messages in the queue cannot be sent by this or any
+                 * other thread.
+                 * Other threads will sooner or later (when receiving or
+                 * sending the next message) get the same IOException and
+                 * get to the same conclusion.
+                 */
+                
+                try {
+                    sendMessage(msg);
+                } catch (IOException e) {
+                    return;
+                }
+            }
+        }
+    }
+    
+    
+    class HandlerEntry {
+        MessageHandler mh;
+        int low;
+        int high;
+    }
+    
+    
+    public void changeRecvCipher(BlockCipher bc, MAC mac) {
+        tc.changeRecvCipher(bc, mac);
+    }
+    
+    
+    public void changeSendCipher(BlockCipher bc, MAC mac) {
+        tc.changeSendCipher(bc, mac);
+    }
+    
+    protected abstract void transportClose() throws IOException;
+    protected abstract InputStream getInputStream() throws IOException;
+    protected abstract OutputStream getOutputStream() throws IOException;
+    protected abstract void establishConnection(ProxyData proxyData, int connectTimeout) throws IOException;
+    
+    public void initialize(CryptoWishList cwl, ServerHostKeyVerifier verifier, DHGexParameters dhgex,
+            int connectTimeout, SecureRandom rnd, ProxyData proxyData) throws IOException {
+        /* First, establish the TCP connection to the SSH-2 server */
+        
+        establishConnection(proxyData, connectTimeout);
+        
+                /* Parse the server line and say hello - important: this information is later needed for the
+                 * key exchange (to stop man-in-the-middle attacks) - that is why we wrap it into an object
+                 * for later use.
+                 */
+        
+        ClientServerHello csh = new ClientServerHello(getInputStream(), getOutputStream());
+        
+        tc = new TransportConnection(getInputStream(), getOutputStream(), rnd);
+        
+        km = new KexManager(this, csh, cwl, hostname, port, verifier, rnd);
+        km.initiateKEX(cwl, dhgex);
+        
+        receiveThread = new Thread(new Runnable() {
+            public void run() {
+                try {
+                    receiveLoop();
+                } catch (IOException e) {
+                    close(e, false);
+                    
+                    if (log.isEnabled())
+                        log.log(10, "Receive thread: error in receiveLoop: " + e.getMessage());
+                }
+                
+                if (log.isEnabled())
+                    log.log(50, "Receive thread: back from receiveLoop");
+                
+                /* Tell all handlers that it is time to say goodbye */
+                
+                if (km != null) {
+                    try {
+                        km.handleMessage(null, 0);
+                    } catch (IOException e) {
+                    }
+                }
+                
+                for (int i = 0; i < messageHandlers.size(); i++) {
+                    HandlerEntry he = (HandlerEntry) messageHandlers.elementAt(i);
+                    try {
+                        he.mh.handleMessage(null, 0);
+                    } catch (Exception ignore) {
+                    }
+                }
+            }
+        });
+        
+        receiveThread.setDaemon(true);
+        receiveThread.start();
+    }
+    
+    public void close(Throwable cause, boolean useDisconnectPacket) {
+        if (useDisconnectPacket == false) {
+                        /* OK, hard shutdown - do not aquire the semaphore,
+                         * perhaps somebody is inside (and waits until the remote
+                         * side is ready to accept new data). */
+            
+            try {
+                transportClose();
+            } catch (IOException ignore) {
+            }
+            
+                        /* OK, whoever tried to send data, should now agree that
+                         * there is no point in further waiting =)
+                         * It is safe now to aquire the semaphore.
+                         */
+        }
+        
+        synchronized (connectionSemaphore) {
+            if (connectionClosed == false) {
+                if (useDisconnectPacket == true) {
+                    try {
+                        byte[] msg = new PacketDisconnect(Packets.SSH_DISCONNECT_BY_APPLICATION, cause.getMessage(), "")
+                        .getPayload();
+                        if (tc != null)
+                            tc.sendMessage(msg);
+                    } catch (IOException ignore) {
+                    }
+                    
+                    try {
+                        transportClose();
+                    } catch (IOException ignore) {
+                    }
+                }
+                
+                connectionClosed = true;
+                reasonClosedCause = cause; /* may be null */
+            }
+            connectionSemaphore.notifyAll();
+        }
+        
+        /* No check if we need to inform the monitors */
+        
+        Vector monitors = null;
+        
+        synchronized (this) {
+                        /* Short term lock to protect "connectionMonitors"
+                         * and "monitorsWereInformed"
+                         * (they may be modified concurrently)
+                         */
+            
+            if (monitorsWereInformed == false) {
+                monitorsWereInformed = true;
+                monitors = (Vector) connectionMonitors.clone();
+            }
+        }
+        
+        if (monitors != null) {
+            for (int i = 0; i < monitors.size(); i++) {
+                try {
+                    ConnectionMonitor cmon = (ConnectionMonitor) monitors.elementAt(i);
+                    cmon.connectionLost(reasonClosedCause);
+                } catch (Exception ignore) {
+                }
+            }
+        }
+    }
+    
+    
+    public void forceKeyExchange(CryptoWishList cwl, DHGexParameters dhgex) throws IOException {
+        km.initiateKEX(cwl, dhgex);
+    }
+    
+    
+    public ConnectionInfo getConnectionInfo(int kexNumber) throws IOException {
+        return km.getOrWaitForConnectionInfo(kexNumber);
+    }
+    
+    
+    public int getPacketOverheadEstimate() {
+        return tc.getPacketOverheadEstimate();
+    }
+    
+    
+    public Throwable getReasonClosedCause() {
+        synchronized (connectionSemaphore) {
+            return reasonClosedCause;
+        }
+    }
+    
+    
+    public byte[] getSessionIdentifier() {
+        return km.sessionId;
+    }
+    
+    
+    public void kexFinished() throws IOException {
+        synchronized (connectionSemaphore) {
+            flagKexOngoing = false;
+            connectionSemaphore.notifyAll();
+        }
+    }
+    
+    
+    public void receiveLoop() throws IOException {
+        byte[] msg = new byte[35000];
+        
+        while (true) {
+            int msglen = tc.receiveMessage(msg, 0, msg.length);
+            
+            int type = msg[0] & 0xff;
+            
+            if (type == Packets.SSH_MSG_IGNORE)
+                continue;
+            
+            if (type == Packets.SSH_MSG_DEBUG) {
+                if (log.isEnabled()) {
+                    TypesReader tr = new TypesReader(msg, 0, msglen);
+                    tr.readByte();
+                    tr.readBoolean();
+                    StringBuffer debugMessageBuffer = new StringBuffer();
+                    debugMessageBuffer.append(tr.readString("UTF-8"));
+                    
+                    for (int i = 0; i < debugMessageBuffer.length(); i++) {
+                        char c = debugMessageBuffer.charAt(i);
+                        
+                        if ((c >= 32) && (c <= 126))
+                            continue;
+                        debugMessageBuffer.setCharAt(i, '\uFFFD');
+                    }
+                    
+                    log.log(50, "DEBUG Message from remote: '" + debugMessageBuffer.toString() + "'");
+                }
+                continue;
+            }
+            
+            if (type == Packets.SSH_MSG_UNIMPLEMENTED) {
+                throw new IOException("Peer sent UNIMPLEMENTED message, that should not happen.");
+            }
+            
+            if (type == Packets.SSH_MSG_DISCONNECT) {
+                TypesReader tr = new TypesReader(msg, 0, msglen);
+                tr.readByte();
+                int reason_code = tr.readUINT32();
+                StringBuffer reasonBuffer = new StringBuffer();
+                reasonBuffer.append(tr.readString("UTF-8"));
+                
+                /*
+                 * Do not get fooled by servers that send abnormal long error
+                 * messages
+                 */
+                
+                if (reasonBuffer.length() > 255) {
+                    reasonBuffer.setLength(255);
+                    reasonBuffer.setCharAt(254, '.');
+                    reasonBuffer.setCharAt(253, '.');
+                    reasonBuffer.setCharAt(252, '.');
+                }
+                
+                /*
+                 * Also, check that the server did not send charcaters that may
+                 * screw up the receiver -> restrict to reasonable US-ASCII
+                 * subset -> "printable characters" (ASCII 32 - 126). Replace
+                 * all others with 0xFFFD (UNICODE replacement character).
+                 */
+                
+                for (int i = 0; i < reasonBuffer.length(); i++) {
+                    char c = reasonBuffer.charAt(i);
+                    
+                    if ((c >= 32) && (c <= 126))
+                        continue;
+                    reasonBuffer.setCharAt(i, '\uFFFD');
+                }
+                
+                throw new IOException("Peer sent DISCONNECT message (reason code " + reason_code + "): "
+                        + reasonBuffer.toString());
+            }
+            
+            /*
+             * Is it a KEX Packet?
+             */
+            
+            if ((type == Packets.SSH_MSG_KEXINIT) || (type == Packets.SSH_MSG_NEWKEYS) || ((type >= 30) && (type <= 49))) {
+                km.handleMessage(msg, msglen);
+                continue;
+            }
+            
+            MessageHandler mh = null;
+            
+            for (int i = 0; i < messageHandlers.size(); i++) {
+                HandlerEntry he = (HandlerEntry) messageHandlers.elementAt(i);
+                if ((he.low <= type) && (type <= he.high)) {
+                    mh = he.mh;
+                    break;
+                }
+            }
+            
+            if (mh == null)
+                throw new IOException("Unexpected SSH message (type " + type + ")");
+            
+            mh.handleMessage(msg, msglen);
+        }
+    }
+    
+    
+    public void registerMessageHandler(MessageHandler mh, int low, int high) {
+        HandlerEntry he = new HandlerEntry();
+        he.mh = mh;
+        he.low = low;
+        he.high = high;
+        
+        synchronized (messageHandlers) {
+            messageHandlers.addElement(he);
+        }
+    }
+    
+    
+    public void removeMessageHandler(MessageHandler mh, int low, int high) {
+        synchronized (messageHandlers) {
+            for (int i = 0; i < messageHandlers.size(); i++) {
+                HandlerEntry he = (HandlerEntry) messageHandlers.elementAt(i);
+                if ((he.mh == mh) && (he.low == low) && (he.high == high)) {
+                    messageHandlers.removeElementAt(i);
+                    break;
+                }
+            }
+        }
+    }
+    
+    
+    public void sendAsynchronousMessage(byte[] msg) throws IOException {
+        synchronized (asynchronousQueue) {
+            asynchronousQueue.addElement(msg);
+            
+            /* This limit should be flexible enough. We need this, otherwise the peer
+             * can flood us with global requests (and other stuff where we have to reply
+             * with an asynchronous message) and (if the server just sends data and does not
+             * read what we send) this will probably put us in a low memory situation
+             * (our send queue would grow and grow and...) */
+            
+            if (asynchronousQueue.size()  > 100)
+                throw new IOException("Error: the peer is not consuming our asynchronous replies.");
+            
+            /* Check if we have an asynchronous sending thread */
+            
+            if (asynchronousThread == null) {
+                asynchronousThread = new AsynchronousWorker();
+                asynchronousThread.setDaemon(true);
+                asynchronousThread.start();
+                
+                /* The thread will stop after 2 seconds of inactivity (i.e., empty queue) */
+            }
+        }
+    }
+    
+    
+    public void sendKexMessage(byte[] msg) throws IOException {
+        synchronized (connectionSemaphore) {
+            if (connectionClosed) {
+                throw (IOException) new IOException("Sorry, this connection is closed.").initCause(reasonClosedCause);
+            }
+            
+            flagKexOngoing = true;
+            
+            try {
+                tc.sendMessage(msg);
+            } catch (IOException e) {
+                close(e, false);
+                throw e;
+            }
+        }
+    }
+    
+    
+    public void sendMessage(byte[] msg) throws IOException {
+        if (Thread.currentThread()  == receiveThread)
+            throw new IOException("Assertion error: sendMessage may never be invoked by the receiver thread!");
+        synchronized (connectionSemaphore) {
+            while (true) {
+                if (connectionClosed) {
+                    throw (IOException) new IOException("Sorry, this connection is closed.").initCause(reasonClosedCause);
+                }
+                
+                if (flagKexOngoing == false)
+                    break;
+                
+                try {
+                    connectionSemaphore.wait();
+                } catch (InterruptedException e) {
+                }
+            }
+            
+            try {
+                tc.sendMessage(msg);
+            } catch (IOException e) {
+                close(e, false);
+                throw e;
+            }
+        }
+    }
+    
+    
+    public void setConnectionMonitors(Vector monitors) {
+        synchronized (this) {
+            connectionMonitors = (Vector) monitors.clone();
+        }
+    }
+
+    public abstract void setTcpNoDelay(boolean tcpNoDelay) throws IOException;    
+}
diff -urN -x '*.svn' src.orig/com/trilead/ssh2/transport/KexManager.java src/com/trilead/ssh2/transport/KexManager.java
--- src.orig/com/trilead/ssh2/transport/KexManager.java	2008-04-01 14:48:37.000000000 +0200
+++ src/com/trilead/ssh2/transport/KexManager.java	2008-07-29 15:37:16.000000000 +0200
@@ -56,7 +56,7 @@
 
 	boolean ignore_next_kex_packet = false;
 
-	final TransportManager tm;
+	final GenericTransportManager tm;
 
 	CryptoWishList nextKEXcryptoWishList;
 	DHGexParameters nextKEXdhgexParameters;
@@ -66,7 +66,7 @@
 	final int port;
 	final SecureRandom rnd;
 
-	public KexManager(TransportManager tm, ClientServerHello csh, CryptoWishList initialCwl, String hostname, int port,
+	public KexManager(GenericTransportManager tm, ClientServerHello csh, CryptoWishList initialCwl, String hostname, int port,
 			ServerHostKeyVerifier keyVerifier, SecureRandom rnd)
 	{
 		this.tm = tm;
diff -urN -x '*.svn' src.orig/com/trilead/ssh2/transport/StreamTransportManager.java src/com/trilead/ssh2/transport/StreamTransportManager.java
--- src.orig/com/trilead/ssh2/transport/StreamTransportManager.java	1970-01-01 01:00:00.000000000 +0100
+++ src/com/trilead/ssh2/transport/StreamTransportManager.java	2008-07-29 15:37:16.000000000 +0200
@@ -0,0 +1,59 @@
+/*
+ * StreamTransportManager.java
+ *
+ * Created on April 14, 2007, 7:53 PM
+ */
+
+package com.trilead.ssh2.transport;
+
+import com.trilead.ssh2.DHGexParameters;
+import com.trilead.ssh2.LocalStreamForwarder;
+import com.trilead.ssh2.ProxyData;
+import com.trilead.ssh2.ServerHostKeyVerifier;
+import com.trilead.ssh2.crypto.CryptoWishList;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.security.SecureRandom;
+
+/**
+ *
+ * @author Juraj Bednar, juraj.bednar@digmia.com
+ */
+public class StreamTransportManager extends GenericTransportManager {
+    
+    private LocalStreamForwarder stream = null;
+    
+    public StreamTransportManager(String host, int port) {
+        super(host, port);
+    }
+    
+    public StreamTransportManager(String host, int port, LocalStreamForwarder stream) {
+        super(host, port);
+        this.stream = stream;
+    }
+
+    protected void transportClose() throws IOException {
+        stream.close();
+    }
+
+    protected InputStream getInputStream() throws IOException {
+        return stream.getInputStream();
+    }
+
+    protected OutputStream getOutputStream() throws IOException {
+        return stream.getOutputStream();
+    }
+
+    protected void establishConnection(ProxyData proxyData, int connectTimeout) throws IOException {
+        // nothing to do, stream is already initialized
+        if (stream == null) {
+            throw new IOException("Stream can not be null");
+        }
+    }
+
+    public void setTcpNoDelay(boolean tcpNoDelay) {
+        // no control of underlying socket
+    }
+    
+}
diff -urN -x '*.svn' src.orig/com/trilead/ssh2/transport/TransportManager.java src/com/trilead/ssh2/transport/TransportManager.java
--- src.orig/com/trilead/ssh2/transport/TransportManager.java	2008-04-01 14:48:37.000000000 +0200
+++ src/com/trilead/ssh2/transport/TransportManager.java	2008-07-29 15:37:16.000000000 +0200
@@ -9,6 +9,7 @@
 import java.net.Socket;
 import java.net.UnknownHostException;
 import java.security.SecureRandom;
+import java.util.Iterator;
 import java.util.Vector;
 
 import com.trilead.ssh2.ConnectionInfo;
@@ -51,98 +52,11 @@
  * @author Christian Plattner, plattner@trilead.com
  * @version $Id: TransportManager.java,v 1.2 2008/04/01 12:38:09 cplattne Exp $
  */
-public class TransportManager
+public class TransportManager extends GenericTransportManager
 {
-	private static final Logger log = Logger.getLogger(TransportManager.class);
 
-	class HandlerEntry
-	{
-		MessageHandler mh;
-		int low;
-		int high;
-	}
-
-	private final Vector asynchronousQueue = new Vector();
-	private Thread asynchronousThread = null;
-
-	class AsynchronousWorker extends Thread
-	{
-		public void run()
-		{
-			while (true)
-			{
-				byte[] msg = null;
-
-				synchronized (asynchronousQueue)
-				{
-					if (asynchronousQueue.size() == 0)
-					{
-						/* After the queue is empty for about 2 seconds, stop this thread */
-
-						try
-						{
-							asynchronousQueue.wait(2000);
-						}
-						catch (InterruptedException e)
-						{
-							/* OKOK, if somebody interrupts us, then we may die earlier. */
-						}
-
-						if (asynchronousQueue.size() == 0)
-						{
-							asynchronousThread = null;
-							return;
-						}
-					}
-
-					msg = (byte[]) asynchronousQueue.remove(0);
-				}
-
-				/* The following invocation may throw an IOException.
-				 * There is no point in handling it - it simply means
-				 * that the connection has a problem and we should stop
-				 * sending asynchronously messages. We do not need to signal that
-				 * we have exited (asynchronousThread = null): further
-				 * messages in the queue cannot be sent by this or any
-				 * other thread.
-				 * Other threads will sooner or later (when receiving or
-				 * sending the next message) get the same IOException and
-				 * get to the same conclusion.
-				 */
-
-				try
-				{
-					sendMessage(msg);
-				}
-				catch (IOException e)
-				{
-					return;
-				}
-			}
-		}
-	}
-
-	String hostname;
-	int port;
 	final Socket sock = new Socket();
 
-	Object connectionSemaphore = new Object();
-
-	boolean flagKexOngoing = false;
-	boolean connectionClosed = false;
-
-	Throwable reasonClosedCause = null;
-
-	TransportConnection tc;
-	KexManager km;
-
-	Vector messageHandlers = new Vector();
-
-	Thread receiveThread;
-
-	Vector connectionMonitors = new Vector();
-	boolean monitorsWereInformed = false;
-
 	/**
 	 * There were reports that there are JDKs which use
 	 * the resolver even though one supplies a dotted IP
@@ -206,13 +120,7 @@
 
 	public TransportManager(String host, int port) throws IOException
 	{
-		this.hostname = host;
-		this.port = port;
-	}
-
-	public int getPacketOverheadEstimate()
-	{
-		return tc.getPacketOverheadEstimate();
+		super(host, port);
 	}
 
 	public void setTcpNoDelay(boolean state) throws IOException
@@ -225,113 +133,11 @@
 		sock.setSoTimeout(timeout);
 	}
 
-	public ConnectionInfo getConnectionInfo(int kexNumber) throws IOException
-	{
-		return km.getOrWaitForConnectionInfo(kexNumber);
-	}
-
-	public Throwable getReasonClosedCause()
-	{
-		synchronized (connectionSemaphore)
-		{
-			return reasonClosedCause;
-		}
-	}
-
-	public byte[] getSessionIdentifier()
-	{
-		return km.sessionId;
-	}
-
-	public void close(Throwable cause, boolean useDisconnectPacket)
-	{
-		if (useDisconnectPacket == false)
-		{
-			/* OK, hard shutdown - do not aquire the semaphore,
-			 * perhaps somebody is inside (and waits until the remote
-			 * side is ready to accept new data). */
-
-			try
-			{
-				sock.close();
-			}
-			catch (IOException ignore)
-			{
-			}
-
-			/* OK, whoever tried to send data, should now agree that
-			 * there is no point in further waiting =)
-			 * It is safe now to aquire the semaphore.
-			 */
-		}
-
-		synchronized (connectionSemaphore)
-		{
-			if (connectionClosed == false)
-			{
-				if (useDisconnectPacket == true)
-				{
-					try
-					{
-						byte[] msg = new PacketDisconnect(Packets.SSH_DISCONNECT_BY_APPLICATION, cause.getMessage(), "")
-								.getPayload();
-						if (tc != null)
-							tc.sendMessage(msg);
-					}
-					catch (IOException ignore)
-					{
-					}
-
-					try
-					{
-						sock.close();
-					}
-					catch (IOException ignore)
-					{
-					}
-				}
-
-				connectionClosed = true;
-				reasonClosedCause = cause; /* may be null */
-			}
-			connectionSemaphore.notifyAll();
-		}
-
-		/* No check if we need to inform the monitors */
-
-		Vector monitors = null;
-
-		synchronized (this)
-		{
-			/* Short term lock to protect "connectionMonitors"
-			 * and "monitorsWereInformed"
-			 * (they may be modified concurrently)
-			 */
-
-			if (monitorsWereInformed == false)
-			{
-				monitorsWereInformed = true;
-				monitors = (Vector) connectionMonitors.clone();
-			}
-		}
-
-		if (monitors != null)
-		{
-			for (int i = 0; i < monitors.size(); i++)
-			{
-				try
-				{
-					ConnectionMonitor cmon = (ConnectionMonitor) monitors.elementAt(i);
-					cmon.connectionLost(reasonClosedCause);
-				}
-				catch (Exception ignore)
-				{
-				}
-			}
-		}
-	}
-
-	private void establishConnection(ProxyData proxyData, int connectTimeout) throws IOException
+        protected void transportClose() throws IOException {
+            sock.close();
+        }
+        
+	protected void establishConnection(ProxyData proxyData, int connectTimeout) throws IOException
 	{
 		/* See the comment for createInetAddress() */
 
@@ -441,336 +247,14 @@
 		throw new IOException("Unsupported ProxyData");
 	}
 
-	public void initialize(CryptoWishList cwl, ServerHostKeyVerifier verifier, DHGexParameters dhgex,
-			int connectTimeout, SecureRandom rnd, ProxyData proxyData) throws IOException
-	{
-		/* First, establish the TCP connection to the SSH-2 server */
-
-		establishConnection(proxyData, connectTimeout);
-
-		/* Parse the server line and say hello - important: this information is later needed for the
-		 * key exchange (to stop man-in-the-middle attacks) - that is why we wrap it into an object
-		 * for later use.
-		 */
-
-		ClientServerHello csh = new ClientServerHello(sock.getInputStream(), sock.getOutputStream());
-
-		tc = new TransportConnection(sock.getInputStream(), sock.getOutputStream(), rnd);
-
-		km = new KexManager(this, csh, cwl, hostname, port, verifier, rnd);
-		km.initiateKEX(cwl, dhgex);
-
-		receiveThread = new Thread(new Runnable()
-		{
-			public void run()
-			{
-				try
-				{
-					receiveLoop();
-				}
-				catch (IOException e)
-				{
-					close(e, false);
-
-					if (log.isEnabled())
-						log.log(10, "Receive thread: error in receiveLoop: " + e.getMessage());
-				}
-
-				if (log.isEnabled())
-					log.log(50, "Receive thread: back from receiveLoop");
-
-				/* Tell all handlers that it is time to say goodbye */
-
-				if (km != null)
-				{
-					try
-					{
-						km.handleMessage(null, 0);
-					}
-					catch (IOException e)
-					{
-					}
-				}
-
-				for (int i = 0; i < messageHandlers.size(); i++)
-				{
-					HandlerEntry he = (HandlerEntry) messageHandlers.elementAt(i);
-					try
-					{
-						he.mh.handleMessage(null, 0);
-					}
-					catch (Exception ignore)
-					{
-					}
-				}
-			}
-		});
-
-		receiveThread.setDaemon(true);
-		receiveThread.start();
-	}
-
-	public void registerMessageHandler(MessageHandler mh, int low, int high)
-	{
-		HandlerEntry he = new HandlerEntry();
-		he.mh = mh;
-		he.low = low;
-		he.high = high;
-
-		synchronized (messageHandlers)
-		{
-			messageHandlers.addElement(he);
-		}
-	}
-
-	public void removeMessageHandler(MessageHandler mh, int low, int high)
-	{
-		synchronized (messageHandlers)
-		{
-			for (int i = 0; i < messageHandlers.size(); i++)
-			{
-				HandlerEntry he = (HandlerEntry) messageHandlers.elementAt(i);
-				if ((he.mh == mh) && (he.low == low) && (he.high == high))
-				{
-					messageHandlers.removeElementAt(i);
-					break;
-				}
-			}
-		}
-	}
-
-	public void sendKexMessage(byte[] msg) throws IOException
-	{
-		synchronized (connectionSemaphore)
-		{
-			if (connectionClosed)
-			{
-				throw (IOException) new IOException("Sorry, this connection is closed.").initCause(reasonClosedCause);
-			}
-
-			flagKexOngoing = true;
-
-			try
-			{
-				tc.sendMessage(msg);
-			}
-			catch (IOException e)
-			{
-				close(e, false);
-				throw e;
-			}
-		}
-	}
-
-	public void kexFinished() throws IOException
-	{
-		synchronized (connectionSemaphore)
-		{
-			flagKexOngoing = false;
-			connectionSemaphore.notifyAll();
-		}
-	}
-
-	public void forceKeyExchange(CryptoWishList cwl, DHGexParameters dhgex) throws IOException
-	{
-		km.initiateKEX(cwl, dhgex);
-	}
-
-	public void changeRecvCipher(BlockCipher bc, MAC mac)
-	{
-		tc.changeRecvCipher(bc, mac);
-	}
-
-	public void changeSendCipher(BlockCipher bc, MAC mac)
-	{
-		tc.changeSendCipher(bc, mac);
-	}
-
-	public void sendAsynchronousMessage(byte[] msg) throws IOException
-	{
-		synchronized (asynchronousQueue)
-		{
-			asynchronousQueue.addElement(msg);
-
-			/* This limit should be flexible enough. We need this, otherwise the peer
-			 * can flood us with global requests (and other stuff where we have to reply
-			 * with an asynchronous message) and (if the server just sends data and does not
-			 * read what we send) this will probably put us in a low memory situation
-			 * (our send queue would grow and grow and...) */
-
-			if (asynchronousQueue.size() > 100)
-				throw new IOException("Error: the peer is not consuming our asynchronous replies.");
-
-			/* Check if we have an asynchronous sending thread */
-
-			if (asynchronousThread == null)
-			{
-				asynchronousThread = new AsynchronousWorker();
-				asynchronousThread.setDaemon(true);
-				asynchronousThread.start();
-
-				/* The thread will stop after 2 seconds of inactivity (i.e., empty queue) */
-			}
-		}
-	}
-
-	public void setConnectionMonitors(Vector monitors)
-	{
-		synchronized (this)
-		{
-			connectionMonitors = (Vector) monitors.clone();
-		}
-	}
+        protected InputStream getInputStream() throws IOException {
+            return sock.getInputStream();
+        }
+        
+        protected OutputStream getOutputStream() throws IOException {
+            return sock.getOutputStream();
+        }
+        
 
-	public void sendMessage(byte[] msg) throws IOException
-	{
-		if (Thread.currentThread() == receiveThread)
-			throw new IOException("Assertion error: sendMessage may never be invoked by the receiver thread!");
 
-		synchronized (connectionSemaphore)
-		{
-			while (true)
-			{
-				if (connectionClosed)
-				{
-					throw (IOException) new IOException("Sorry, this connection is closed.")
-							.initCause(reasonClosedCause);
-				}
-
-				if (flagKexOngoing == false)
-					break;
-
-				try
-				{
-					connectionSemaphore.wait();
-				}
-				catch (InterruptedException e)
-				{
-				}
-			}
-
-			try
-			{
-				tc.sendMessage(msg);
-			}
-			catch (IOException e)
-			{
-				close(e, false);
-				throw e;
-			}
-		}
-	}
-
-	public void receiveLoop() throws IOException
-	{
-		byte[] msg = new byte[35000];
-
-		while (true)
-		{
-			int msglen = tc.receiveMessage(msg, 0, msg.length);
-
-			int type = msg[0] & 0xff;
-
-			if (type == Packets.SSH_MSG_IGNORE)
-				continue;
-
-			if (type == Packets.SSH_MSG_DEBUG)
-			{
-				if (log.isEnabled())
-				{
-					TypesReader tr = new TypesReader(msg, 0, msglen);
-					tr.readByte();
-					tr.readBoolean();
-					StringBuffer debugMessageBuffer = new StringBuffer();
-					debugMessageBuffer.append(tr.readString("UTF-8"));
-
-					for (int i = 0; i < debugMessageBuffer.length(); i++)
-					{
-						char c = debugMessageBuffer.charAt(i);
-
-						if ((c >= 32) && (c <= 126))
-							continue;
-						debugMessageBuffer.setCharAt(i, '\uFFFD');
-					}
-
-					log.log(50, "DEBUG Message from remote: '" + debugMessageBuffer.toString() + "'");
-				}
-				continue;
-			}
-
-			if (type == Packets.SSH_MSG_UNIMPLEMENTED)
-			{
-				throw new IOException("Peer sent UNIMPLEMENTED message, that should not happen.");
-			}
-
-			if (type == Packets.SSH_MSG_DISCONNECT)
-			{
-				TypesReader tr = new TypesReader(msg, 0, msglen);
-				tr.readByte();
-				int reason_code = tr.readUINT32();
-				StringBuffer reasonBuffer = new StringBuffer();
-				reasonBuffer.append(tr.readString("UTF-8"));
-
-				/*
-				 * Do not get fooled by servers that send abnormal long error
-				 * messages
-				 */
-
-				if (reasonBuffer.length() > 255)
-				{
-					reasonBuffer.setLength(255);
-					reasonBuffer.setCharAt(254, '.');
-					reasonBuffer.setCharAt(253, '.');
-					reasonBuffer.setCharAt(252, '.');
-				}
-
-				/*
-				 * Also, check that the server did not send charcaters that may
-				 * screw up the receiver -> restrict to reasonable US-ASCII
-				 * subset -> "printable characters" (ASCII 32 - 126). Replace
-				 * all others with 0xFFFD (UNICODE replacement character).
-				 */
-
-				for (int i = 0; i < reasonBuffer.length(); i++)
-				{
-					char c = reasonBuffer.charAt(i);
-
-					if ((c >= 32) && (c <= 126))
-						continue;
-					reasonBuffer.setCharAt(i, '\uFFFD');
-				}
-
-				throw new IOException("Peer sent DISCONNECT message (reason code " + reason_code + "): "
-						+ reasonBuffer.toString());
-			}
-
-			/*
-			 * Is it a KEX Packet?
-			 */
-
-			if ((type == Packets.SSH_MSG_KEXINIT) || (type == Packets.SSH_MSG_NEWKEYS)
-					|| ((type >= 30) && (type <= 49)))
-			{
-				km.handleMessage(msg, msglen);
-				continue;
-			}
-
-			MessageHandler mh = null;
-
-			for (int i = 0; i < messageHandlers.size(); i++)
-			{
-				HandlerEntry he = (HandlerEntry) messageHandlers.elementAt(i);
-				if ((he.low <= type) && (type <= he.high))
-				{
-					mh = he.mh;
-					break;
-				}
-			}
-
-			if (mh == null)
-				throw new IOException("Unexpected SSH message (type " + type + ")");
-
-			mh.handleMessage(msg, msglen);
-		}
-	}
 }
